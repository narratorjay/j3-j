import bpy
import bmesh
import numpy as np
import os
import csv
import math


''' This code is backed up on GitHub using lunar.txt, 
do not try to save .blend files there

Removed nine items (cylinders,blocks and an icosphere) 
comprising a lunar base in the original landscape from TurboSquid
with this code:
 
BaseBuildings = bpy.data.collections.get('base') 
for Building in BaseBuildings.objects:
    bpy.data.objects.remove(Building, do_unlink=True)
bpy.data.collections.remove(BaseBuildings) '''

# create glitch object collection dictionary
def AddGlitchVersions(form, ShapeSuffixes):
    print('form:', form, '  ShapeSuffixes:', ShapeSuffixes)
    for group in ShapeSuffixes:
        GlitchGroup = form + group
        GlitchGroupName = GlitchGroup + 'Group'
        GlitchMembers = []
        for s in GlitchItems:
            GlitchMembers.append(GlitchGroup + s)
        GlitchDict[GlitchGroup] = GlitchMembers
    
    GlitchDict[GlitchGroup] = GlitchMembers


def PlaceCreateGlitch(Stub, Centre, Spin, Dims):
    
    
    
    MatchingStub = False
    MatchingList = []
    StubGroup = []
    
    if Stub+'a' in list(GlitchDict.keys()):
        for PuzzlePiece in GroupSuffixes:
            for g in range(len(GlitchItems)):
                NewName = Stub + PuzzlePiece + GlitchItems[g]
                #print('NewName for item', NewName)
                for c in range(len(Centre)):
                    Centre[c] = Centre[c] + Offsets[g]
                    Spin[c] = Spin[c] + Offsets[g]
                    Dims[c] = Dims[c] + Offsets[g]                     
                
                if Stub[:1] == 'B':
                    bpy.ops.mesh.primitive_cube_add( location = (Centre[0], Centre[1], Centre[2]), rotation = (Spin[0], Spin[1], Spin[2]), scale = (Dims[0], Dims[1], Dims[2]) )
                    bpy.context.active_object.name = NewName
                    bpy.context.active_object.data.name = NewName
                    #StubGroup += [GlitchNewName] # done in dictionary earlier
                    bpy.data.objects[NewName].active_material = acrylicBpyMat
                    
                if Stub[:1] == 'S':
                    bpy.ops.mesh.primitive_uv_sphere_add(segments = 128, ring_count = 64, radius = 0.01 + Dims[0], location = (Centre[0], Centre[1], Centre[2]) )
                    bpy.context.active_object.name = NewName
                    bpy.context.active_object.data.name = NewName                            
                ### treat spheres differently, there are not six of them            
                    
        
        #SixBlocks = list(GlitchDict.keys)
        #for Base
        
    
    ''' old method without GlitchGroups
    
    for item in bpy.context.scene.objects:
        if item.name[:4] == Stub:
            MatchingStub = True
            MatchingList.append(item.name)
        if MatchingStub:
            LastLetterOfLastMatch = MatchingList[-1:][-1][-1]  # last list item, last item, last letter 
            AlphabetPosition = GroupSuffixes.index(LastLetterOfLastMatch)
            NextSuffix = GroupSuffixes[AlphabetPosition + 1]
            NewName = Stub + NextSuffix
        else:
            NewName = Stub + 'a'
            
    if Stub[:1] == 'B':
        for g in range(len(GlitchBlocks)):
            GlitchNewName = NewName + GlitchBlocks[g]
            for c in range(len(Centre)):
                Centre[c] = Centre[c] + Offsets[g]
                Spin[c] = Spin[c] + Offsets[g]
                Dims[c] = Dims[c] + Offsets[g]   
            
            bpy.ops.mesh.primitive_cube_add( location = (Centre[0], Centre[1], Centre[2]), rotation = (Spin[0], Spin[1], Spin[2]), scale = (Dims[0], Dims[1], Dims[2]) )
            bpy.context.active_object.name = GlitchNewName
            bpy.context.active_object.data.name = GlitchNewName
            StubGroup += [GlitchNewName]
            bpy.data.objects[GlitchNewName].active_material = acrylicBpyMat
    
    if Stub[:1] == 'S':
        for g in range(len(GlitchBlocks)):
            GlitchNewName = NewName + GlitchBlocks[g]
            for c in range(len(Centre)):
                Centre[c] = Centre[c] + Offsets[g]
                Dims[c] = Dims[c] + Offsets[g]
                
            bpy.ops.mesh.primitive_uv_sphere_add(segments = 128, ring_count = 64, radius = 0.01 + Dims[0], location = (Centre[0], Centre[1], Centre[2]) )    
            bpy.context.active_object.name = GlitchNewName
            bpy.context.active_object.data.name = GlitchNewName
            StubGroup += [GlitchNewName]
            if GlitchNewName[5:] == 'v':
                bpy.data.objects[GlitchNewName].active_material = SphereSteel
            else:
                bpy.data.objects[GlitchNewName].active_material = acrylicBpyMat  
                # glitched spheres are acrylic'''
                
    return(StubGroup)

# matrix operations to aid solving with Python later
def RotateBlocksAboutSpheres(BCoords, BDims, NameRootAppend):
    print('fn RotateBlocksAboutSpheres BCoords, BDims, NameRootAppend:  ', BCoords, BDims, NameRootAppend)
    bpy.ops.mesh.primitive_cube_add(location = (BCoords[0], BCoords[1], BCoords[2]), rotation = (0, 0, 0), scale = (BDims))
    FullBlockName = AssignNameMaterial(NameRootAppend)
    bpy.ops.mesh.primitive_cube_add(location = (BCoords[1], BCoords[2], BCoords[0]), rotation = (0, Pi/2, Pi/2), scale = (BDims))
    FullBlockName = AssignNameMaterial(NameRootAppend)
    bpy.ops.mesh.primitive_cube_add(location = (BCoords[2], BCoords[0], BCoords[1]), rotation = (Pi/2, 0, Pi/2), scale = (BDims))
    FullBlockName = AssignNameMaterial(NameRootAppend)
    bpy.ops.mesh.primitive_cube_add(location = (CubeD-BCoords[0], CubeD-BCoords[1], CubeD-BCoords[2]), rotation = (0, 0, 0), scale = (BDims))
    FullBlockName = AssignNameMaterial(NameRootAppend)
    bpy.ops.mesh.primitive_cube_add(location = (CubeD-BCoords[1], CubeD-BCoords[2], CubeD-BCoords[0]), rotation = (0, Pi/2, Pi/2), scale = (BDims))
    FullBlockName = AssignNameMaterial(NameRootAppend)
    bpy.ops.mesh.primitive_cube_add(location = (CubeD-BCoords[2], CubeD-BCoords[0], CubeD-BCoords[1]), rotation = (Pi/2, 0, Pi/2), scale = (BDims))
    FullBlockName = AssignNameMaterial(NameRootAppend)
    print('used RotateBlocksAboutSpheres with matrix size', mD)
    # link the rotations here with the matrix:  (0, Pi/2, Pi/2) for 'b' <->   np.rot90(..., axes = (0, 2)); np.rot90(..., axes = (1, 0))
    # (Pi/2, 0, Pi/2) for 'c' <-> np.rot90(..., axes = (0, 1)); np.rot90(..., axes = (2, 0)) in fn RotateReflectMatrix
    # and BDims aka NewBlockXYZ 

# more matrix operations to aid solving with Python later
def CheckEmptiesForBlock(CornerCell):
    print('CornerCell occupies matrix position:',  CornerCell)
    EmptySpace = True
    StillChecking = True
    
    while EmptySpace and StillChecking:
        for CellX in range(CornerCell[0], CornerCell[0] + MBlockXYZ[0], 1):   # syntax is  range(FromValue, ToValue, StepSize)
            for CellY in range(CornerCell[1], CornerCell[1] + MBlockXYZ[1], 1):
                for CellZ in range(CornerCell[2], CornerCell[2] + MBlockXYZ[2], 1):
                    print('EmptySpace: ', EmptySpace, '   cell (x, y, z): ', CellX, CellY, CellZ)
                    print('Matrix3D[CellX][CellY][CellZ] holds: ', Matrix3D[CellX][CellY][CellZ])
                    if Matrix3D[CellX][CellY][CellZ] != '.':
                        EmptySpace = False
                    else:
                        Matrix3D[CellX][CellY][CellZ] = EachBlock + 'a'
                        # EmptySpace = True

        print('3D \'for\' loops in matrix finished')
        StillChecking = False
        # call fn to fill in cells with 'B-321' suffix 'b', 'c' etc on a different 3D matrix
        # see if matrices can be added, updating Matrix3D as we go
                 
    print('EmptySpace is', str(EmptySpace), ', StillChecking is', str(StillChecking), 'after checking block\'s cells.')
    BlockCofMList = [ CornerCell[0] + MBlockXYZ[0]/2, CornerCell[1] + MBlockXYZ[1]/2, CornerCell[2] + MBlockXYZ[2]/2 ]
    print('CornerCell XYZ positions:',  CornerCell)
    NewBlockXYZ = [MBlockXYZ[0]*0.01, MBlockXYZ[1]*0.01, MBlockXYZ[2]*0.01]
    print('NewBlockXYZ C of M position:', BlockCofMList)
    return(EmptySpace, BlockCofMList, NewBlockXYZ)

# yet more matrix operations to aid solving with Python later
def RotateReflectMatrix(MatrixA):
    for shape in BlockRoots:
        semiMatrixB = np.rot90(MatrixA, axes = (0, 2))   # rotates B321a (flat along x-axis) to B321b (vertical, z)
        MatrixB = np.rot90(semiMatrixB, axes = (1, 0))
        for mx in range(mD):
            for my in range(mD):
                for mz in range(mD):
                    if MatrixB[mx][my][mz][0:4] == shape:
                        MatrixB[mx][my][mz] = shape + 'b'
                         
        semiMatrixC = np.rot90(MatrixA, axes = (0, 1))   # rotates B321a (as above) to B321c (set on edge, aligned along y)
        MatrixC = np.rot90(semiMatrixC, axes = (2, 0))
        for mx in range(mD):
            for my in range(mD):
                for mz in range(mD):
                    if MatrixC[mx][my][mz][0:4] == shape:
                        MatrixC[mx][my][mz] = shape + 'c'
    
    FinalMatrix = FormerMatrix
    rD = mD - 1       # range dimension, rD, is one less than mD, matrix dimension
    for mx in range(mD):
        for my in range(mD):
            for mz in range(mD):
                if FormerMatrix[mx][my][mz][:1] == 'S':
                    FinalMatrix[mx][my][mz] = FormerMatrix[mx][my][mz]
                if MatrixA[mx][my][mz][:4] in BlockRoots:
                    FinalMatrix[mx][my][mz] = MatrixA[mx][my][mz]
                    FinalMatrix[rD - mx][rD - my][rD - mz] = MatrixA[mx][my][mz][:5] + 'd'
                if MatrixB[mx][my][mz][:4] in BlockRoots:
                    FinalMatrix[mx][my][mz] = MatrixB[mx][my][mz]
                    FinalMatrix[rD - mx][rD - my][rD - mz] = MatrixB[mx][my][mz][:5] + 'e'
                if MatrixC[mx][my][mz][:4] in BlockRoots:
                    FinalMatrix[mx][my][mz] = MatrixC[mx][my][mz]
                    FinalMatrix[rD - mx][rD - my][rD - mz] = MatrixC[mx][my][mz][:5] + 'f'                    

    print('FinalMatrix is', FinalMatrix)


def AlignCamLights(NewPosAngle, FrameCount, Tracking, TrackTarget):
    scene.frame_set(FrameCount)
    print('NewPosAngle components are', NewPosAngle, 'FrameCount', FrameCount)
    ItemInfo = bpy.data.objects['camera']
    ItemInfo.location = ( NewPosAngle[0][0], NewPosAngle[0][1], NewPosAngle[0][2] )
    print('NewPosAngle[1] holds values', NewPosAngle[1])
    

    if Tracking:
        TrackingConstraint = ItemInfo.constraints.new('TRACK_TO')
        TrackingConstraint.target = bpy.data.objects[TrackTarget]
        print('camera ItemInfo location and not rotation:', ItemInfo.location)
        ItemInfo.keyframe_insert(data_path = "location",index = -1)
    else:
        ItemInfo.rotation_euler = ( [NewPosAngle[1][0], NewPosAngle[1][1], NewPosAngle[1][2]] )    
        ItemInfo.keyframe_insert(data_path = "location",index = -1)
        ItemInfo.keyframe_insert(data_path = "rotation_euler",index = -1)
        print('Not tracking, camera .rotation_euler values:', ItemInfo.rotation_euler)
        
        ItemInfo = bpy.data.objects['LeftLamp']
        ItemInfo.location = ( [NewPosAngle[0][0] - 2*math.cos(NewPosAngle[1][2]), NewPosAngle[0][1] - 2*math.sin(NewPosAngle[1][2]), NewPosAngle[0][2]] )
        ItemInfo.keyframe_insert(data_path = "location",index = -1)    
        
        ItemInfo = bpy.data.objects['RightLamp']
        ItemInfo.location = ( [NewPosAngle[0][0] + 2*math.cos(NewPosAngle[1][2]), NewPosAngle[0][1] + 2*math.sin(NewPosAngle[1][2]), NewPosAngle[0][2]] )
        ItemInfo.keyframe_insert(data_path = "location",index = -1)
        
        ItemInfo = bpy.data.objects['TopLamp']
        ShortZ = 0.7 * math.sqrt( (math.sin(NewPosAngle[1][0] - Pi/2)) * (math.sin(NewPosAngle[1][0] - Pi/2)) )   # really could have done this with independent axes for scout  
        ItemInfo.location = ( NewPosAngle[0][0] + ShortZ, NewPosAngle[0][1] + ShortZ, 0.7 - ShortZ )
        ItemInfo.keyframe_insert(data_path = "location",index = -1)
    
    # put an  if statement here remove tracking so that re-runs start without tracking
    # TrackingConstraint = ItemInfo.constraints.new('TRACK_TO')
    if Tracking:
        ItemInfo = bpy.data.objects['camera']
        ItemInfo.constraints.remove(TrackingConstraint)
        
### functions end, set scene

# set light ray behaviour, prepare names and matrix, set scene, define materials including temporary tabletop    

# define materials:  steel then acrylic
bpy.data.materials.new('steel')
SphereSteel = bpy.data.materials['steel']
SphereSteel.use_nodes = True
SphereSteel.node_tree.nodes['Principled BSDF'].inputs[0].default_value = (0.262, 0.262, 0.262, 1)    # base colour HSVA
SphereSteel.node_tree.nodes['Principled BSDF'].inputs[3].default_value = (0.457, 0.457, 0.457, 1)    # base colour subsurface
SphereSteel.node_tree.nodes['Principled BSDF'].inputs[4].default_value = 0.96    # metallic
SphereSteel.node_tree.nodes['Principled BSDF'].inputs[7].default_value = 0.05   # roughness 

bpy.data.materials.new('acrylic')
acrylicBpyMat = bpy.data.materials['acrylic']
acrylicBpyMat.use_nodes = True
acrylicNodes = acrylicBpyMat.node_tree.nodes
acrylicRefraction = acrylicNodes.new( type = 'ShaderNodeBsdfRefraction' )
acrylicGlass = acrylicNodes.new( type = 'ShaderNodeBsdfGlass' )
acrylicGlass.inputs[1].default_value = 0.0        
mixShader = acrylicNodes.new( type = 'ShaderNodeMixShader' )        
acrylicOutput = acrylicNodes.new( type = 'ShaderNodeOutputMaterial' )
acrylicShaderLinks = acrylicBpyMat.node_tree.links
link = acrylicShaderLinks.new( acrylicRefraction.outputs[0], mixShader.inputs[1] )
link = acrylicShaderLinks.new( acrylicGlass.outputs[0], mixShader.inputs[2] )
link = acrylicShaderLinks.new( mixShader.outputs[0], acrylicOutput.inputs[0] )
input = acrylicNodes['Material Output'].inputs['Surface']
output = acrylicNodes['Glass BSDF'].outputs['BSDF']
acrylicShaderLinks.new(input, output)

# increase light ray bounces because scene contains transparent acrylic
scene = bpy.context.scene
scene.render.engine = 'CYCLES'
scene.cycles.transparent_max_bounces = 20
scene.cycles.transmission_max_bounces = 20
scene.cycles.diffusion_bounces = 20
scene.cycles.volume_bounces = 8

# define names of components, create matrix
Pi = math.pi
GroupSuffixes = ['a', 'b', 'c', 'd', 'e', 'f']
SphereSuffixes = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']  # yup, nine
GlitchItems = ['v', 'w', 'x', 'y', 'z']
Offsets = [-0.002, -0.001, 0, 0.001, 0.002]
GlitchDict = {}
BlockRoots = ['B321']; BaseSphere = ['S111']; PuzzlePieces = BlockRoots + BaseSphere
AddedCam = ['LowCamera']
ActiveItems = PuzzlePieces + AddedCam
mx = 0;  my = 0;  mz = 0; mD = 4; BScale = 10         # prefix m for matrix which is later scaled *BScale, the diameter of a sphere & length of a cube
SphereSuffixes = SphereSuffixes[:mD]          # sphere quantity matched to matrix size 

CubeD = mD * BScale
Matrix3D = [[['.' for mx in range(mD)] for my in range(mD)] for mz in range(mD)]
print('mx, my, mz, mD values: ', mx, my, mz, mD)

# clear scene of script item debris 
for o in bpy.data.objects:
    print('Object:', o)
    for i in ActiveItems:
        try:
            if o.name[:4] == i[:4]:
                print('Deleting', o.name)
                o.user_clear
                bpy.data.objects.remove(o)
        except ReferenceError as e:
            print(e)

      
for form in PuzzlePieces:
    if form[0] == 'B':
        AddGlitchVersions(form, GroupSuffixes)
    else:
        AddGlitchVersions(form, SphereSuffixes)        


        
print('Check GlitchDict:', GlitchDict)
print('Check first GlitchDict key:', list(GlitchDict.keys())[0])
print('First GlitchDict value:', GlitchDict['B321a'])

# PlaceCreateGlitch(Stub, Centre, Spin, Dims)
DimsFromBlockName = [ BScale*int(BlockRoots[0][1:2]), BScale*int(BlockRoots[0][2:3]), BScale*int(BlockRoots[0][3:4]) ]
PlaceCreateGlitch(BlockRoots[0], [0, 0, 40], [0, 0, 0], DimsFromBlockName)


''' # now get adding blocks with simple motion
for EachBlock in BlockRoots:
    MBlockXYZ = [ int(EachBlock[1:2]), int(EachBlock[2:3]), int(EachBlock[3:4]) ]
    NewBlockXYZ = [MBlockXYZ[0]*BScale, MBlockXYZ[1]*BScale, MBlockXYZ[2]*BScale]
    BDims = NewBlockXYZ
    BCoords = [0, 0, 40]
    bpy.ops.mesh.primitive_cube_add(location = (BCoords[0], BCoords[1], BCoords[2]), rotation = (0, 0, 0), scale = (BDims))
    Stub = EachBlock[0]

### replace the above loop by calling 
# functions
# AssignName
# CreateGlitchVersions
# AssignMaterial

bpy.context.active_object.name = Stub + 'a'
bpy.context.active_object.data.name = Stub + 'a'
# move these two lines elsewhere
bpy.context.active_object.name = 'B321a'
bpy.context.active_object.data.name = 'B321a' '''



# camera
bpy.ops.object.camera_add(enter_editmode = False, align='VIEW', location = (140, -140, 90), rotation = (1.5, 0, 0.8), scale = (1, 1, 1))
bpy.context.active_object.name = 'LowCamera'
bpy.context.active_object.data.name = 'LowCamera'
bpy.context.scene.camera = bpy.data.objects['LowCamera']


'''# basic motion

Frame = 1

# the keyframe line is what was missing before
ItemName = 'B321av'
ItemInfo = bpy.data.objects[ItemName]
bpy.context.scene.frame_set(Frame)
ItemInfo.keyframe_insert(data_path = "location",index = -1)
print('ItemInfo before move:', ItemInfo.location)


Frame = 120

#ItemInfo = bpy.data.objects(ItemName)
bpy.context.scene.frame_set(Frame)
ItemInfo.location = (-3, 0, 100)
ItemInfo.keyframe_insert(data_path = "location",index = -1)
print('ItemInfo after move:', ItemInfo.location)'''





# film from exploratory drone
# glitch
# film drone filming glitching blocks



